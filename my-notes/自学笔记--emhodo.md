# 摘抄：（道理模块）
## 前言
One has no future if one couldn't teach themself
     > - 至少有 99% 的人终生都没有掌握自学能力
     > - 应试教育的确是磨灭自学能力的最有效方法
     > - 焦虑不是被卖方贩卖的产品，焦虑其实是买方长期自行积累的结果。别人无法贩卖给你焦虑，是你自己焦虑 —— 是你自己在为自己不断积累越来越多的焦虑。**但自学能力强的人不焦虑，起码他们不会因为学习以及学习过程而焦虑 —— 这是重大差别。**
> - 生活质量就是这样一点一点被消磨掉的 —— 最消耗生活质量的东西，就是焦虑。
> - 讲大道理的更可能是庸者、失败者，而不是成功者。
> - 不仅讨厌老生常谈，而且偏要对着干，干着干着就把自己变成了另外一个属于那 99% 的另外一个老生……这是 99% 的人终其一生的生动写照。
> - 在自学这件事上，重视一切老生常谈……
> - 自学没有什么 “秘诀”。它是一门手艺，并且，严格意义上来讲，它只是一门手艺。
> - 手艺的特点就是无需天分。手艺的特点就是熟练程度决定一切。从这一点上来看，自学这门手艺和擀饺子皮没什么区别 —— 就那点事，刚开始谁都笨手笨脚，但熟练了之后，就那么回事…… 而已。（**全书精华**）
## 如何证明你真的读过这本书？
更朴素一点，更接近真相的解释是：
> - 那百分之七八十的人，其实是想着给自己一个希望……
—— 等我有空了一定看。嗯。
说来好笑，其实每个人共同拥有的目标之一是这样的：
 成为前百分之二十的少数人……
然而，PK 掉百分之七八十的人的方法真的很简单很简单啊：
 把买来的书都真真切切地认真读过就可以了。
这实在是太简单了罢？！可是…… 我知道你刚刚那个没出息的闪念：
 那我少买书甚至不买书不就可以了吗？
你自己都知道这是荒谬的，却忍不住为你的小聪明得意 —— 其实吧，幸亏有你们在，否则我们怎么混进前百分之二十呢？
**太真实了······**
> - 比特币这个地球上第一个真正被证明为可行的区块链应用中有一个特别重要的概念，叫做 “工作证明”（Proof of Work）—— 你干活了就是干活了，你没干活就是没干活，你的工作是可被证明的……
证明的方法是使用 github.com 这个网站以及版本控制工具 git。（**本来这篇笔记是写在石墨文档上的，因为重复阅读、总结梳理的时候看到这里，竟然发现之前看的那一遍竟然没注意到这个细节，甚至之前好多细节都没注意到，所以反复阅读，重复阅读，及时总结梳理是多么的重要啊！**）
编程入门的门槛之所以高，有个比较特殊的原因：它的知识点结构不是线性的。
- 前置引用：想要理解当前的知识点，需要依赖对以后才能开始学习的知识点的深入理解。
- 学编程中最重要的活动就是 “阅读官方文档”。学 Python 更是如此。
- 有能力只靠阅读就能习得新技能。
- 自己生活工作学习上遇到的所有疑问，书本里应该都有答案 —— 起码有所参考。
- 绝大多数情况下，没人能教你，也不一定有人愿意教你…… 到最后，你想学会或你必须学会什么东西的时候，你只能靠阅读！ —— 因为其实你谁都靠不上……
- 
## git 功能的学习（版本控制器）
- 注册
 > - git config --global user.name your_name  注册名字 可以任意
 > - git config --global user.mail yourl_mail 注册邮箱 可以任意 
- 代码初始化,2个方法：
  > - git clone+github链接（白嫖别人的代码）  
  > - git init （初始化仓库）

- 提交全部版本：
  > - git add .（路径下所有文件提交缓存区）
  > - git commit -m "备注：第一个版本"   （从缓存区更新+备注） 
  > - git checkout HEAD 文件路径 （还原某个文件）
  > - git add main.py
  
- 提交部分版本：
  > - git add main.py（某个文件名）
  > - git commit -m "备注"
  
- git 
  > - what git 直接记录快照，而非差异比较
  > - why 
  > - how
## 为什么把编程当作自学的入口
   - 道理当然很重要；可是，在传递道理的时候，例子相对来看好像更重要
   - 同样的道理，例子不准，人就可能会理解错；例子不精彩，人就可能听不进去；例子居然可以令人震惊，那就可以做到让听众、让读者 “永生不忘”。
  - 编程当做自学入口的六个原因
    > - 1.编程就是无论是谁都能学会的 
    > - 2.编程发展太快，没有老师，只有通过自学看官方文档，同时有助于提高我们分析数据的能力，而不是永远只是作为数据
    > - 3.编程的知识结构接近真实的社会结构都是非线性的，工作中、生活里，充满了各式各样的 “过早引用”。
    > - 4.学习编程可以帮助我们学习英语,编程会让你不得不天天用英语
    > - 5.自学编程对任何人来说都是现实，可行动，可达成的
    > - 6.在这个领域里面自学的人最多
## 只靠阅读习得新技能
- 习得自学能力的终极目标就是：
    > - 有能力只靠阅读就能习得新技能
    > - 退而求其次，尽量只靠阅读习得新技能
- 自己生活工作学习上遇到的所有疑问，书本里应该都有答案 —— 起码有所参考。
- “不是什么东西都可以从书本里学到的……” 这话听起来那么有道理，只不过是因为自己读书不够多、不够对而已。
- 我把那些能给你带来新视野，能让你改变思考模式，甚至能让你拥有一项新技能的内容称之为 “有繁殖能力的内容”。

## 1. 开始阅读前的一些准备
- 其实吧，编程既不是文科也不是理科…… 它更像是 “手工课”。你越学就越清楚这个事实，它就好像是你做木工一样，学会使用一个工具，再学会使用另外一个工具，其实总共就没多少工具。然后，你更多做的是各种拼接的工作，至于能做出什么东西，最后完全靠你的想象力……
- 1.2. 布尔运算
    - 因为程序这个东西，不过是按照一定顺序完成任务的流程（Procedures）。根据定义，日常生活中你做盘蛋炒饭给自己吃，也是完成了一个 “做蛋炒饭” 的程序 —— 你按部就班完成了一系列的步骤，最终做好了一碗蛋炒饭给自己吃 —— 从这个角度望过去，所有的菜谱都是程序……
    - 布尔值 区别大小写 true True 不是一回事
- 1.3 逻辑操作符
    - | 比较操作符 | 意义     | 示例             | 布尔值  |
    - | ----------| -------- | ---------------- | ------- | 
    - | `==`      | 等于     | `1 == 2`         | `False` |
    - | `!=`      | 不等于   | `1 != 2`         | `True`  |
    - | `>`       | 大于     | `1 > 2`          | `False` |
    - | `>=`      | 大于等于 | `1 >= 1`         | `True`  |
    - | `<`       | 小于     | `1 < 2`          | `True`  |
    - | `<=`      | 小于等于 | `1 <= 2`         | `True`  |
    - | `in`      | 属于     | `'a' in 'basic'` | `True`  |
- 1.4 布尔运算操作符
    - or
    - and
    - not
- 函数
    - 每个函数都是一个完整的程序
        - 它有输入 —— 即，它能接收外部通过参数传递的值；
        - 它有处理 —— 即，内部有能够完成某一特定任务的代码；尤其是，它可以根据 “输入” 得到 “输出”；
        - 它有输出 —— 即，它能向外部输送返回值……
- 1.6.3. 注释
    - 在python里面#用作注释给人看而不是机器
- 1.6.4. 操作符
    - 在本节，我们见到的比较操作符可以比较它左右的值，而后返回一个布尔值。
        我们也见过两个整数被**操作符** `%` 连接，左侧作为被除数，右侧作为除数，`11 % 3` 这个表达式的值是 `2`。对于数字，我们可用的操作符有 `+`、`-`、`*`、`/`、`//`、`%`、`**` —— 它们分别代表加、减、乘、除、商、余、幂。 
- 1.7. 总结
    > * 数据：整数、布尔值；操作符；变量、赋值；表达式
    > * 函数、子程序、参数、返回值、调用
    > * 流程控制、分支、循环
    > * 算法、优化
    > * 程序：语句、注释、语句块
    > * 输入、处理、输出
    > * 解释器    
## 值及其相应的运算
- 值
    - 变量
    - 常量
- 值的类型
    > * 布尔值（Boolean Value)
    > * 数字（Numbers）：整数（Int）、浮点数（Float）、复数（Complex Numbers）
    > * 字符串（Strings）
- 操作符
    > * 对两个值进行操作的 `+`、`-` 的优先级最低；
    > * 稍高的是 `*`、`/`、`//`、`%`；
    > * 更高的是对单个值进行操作的 `+`、`-`；
    > * 优先级最高的是 `**`。
- 布尔值操作符
    - 它们之中，优先级最低的是或 `or`，然后是与 `and`, 优先级最高的是非 `not`：
- 逻辑操作符
    - 数值之间还可以使用逻辑操作符，`1 > 2` 返回布尔值 `False`。逻辑操作符有：`<`（小于）、`<=`（小于等于）、`>`（大于）、`>=`（大于等于）、`!=`（不等于）、`==`（等于）。
    - 逻辑操作符的优先级，高于布尔值的操作符，低于数值计算的操作符。
        即：数值计算的操作符优先级最高，其次是逻辑操作符，布尔值的操作符优先级最低。
- 字符串操作符
    > * 1.拼接：`+` 和 `' '`（后者是空格）
    > * 2.拷贝：`*`
    > * 3.逻辑运算：`in`、`not in`；以及，`<`、`<=`、`>`、`>=`、`!=`、`==`
    > * 字符之间，字符串之间，除了 == 和 != 之外，也都可以被逻辑操作符 <、<=、>、>=
    > * 这是因为字符对应着 Unicode 码，字符在被比较的时候，被比较的是对应的 Unicode 码。
    > * 当字符串被比较的时候，将从两个字符串各自的第一个字符开始逐个比较，“一旦决出胜负马上停止
- 列表的操作符
    - 因为列表和字符串一样，都是有序容器（容器还有另外一种是无序容器），所以，它们可用的操作符其实相同：
        - 拼接：+ 和 ' '（后者是空格）
        - 拷贝：*
        - 逻辑运算：in、not in；以及，<、<=、>、>=、!=、==
- 关于布尔值的补充
    > Here are most of the built-in objects considered `False`:
    > 
    > > * constants defined to be false: `None` and `False`.
    > > * zero of any numeric type: `0`, `0.0`, `0j`, `Decimal(0)`, `Fraction(0, 1)` 
    > > * empty sequences and collections: `''`, `()`, `[]`, `{}`, `set()`, `range(0)`
    > 每个变量或者常量，除了它们的值之外，同时还相当于有一个对应的布尔值。
## PART.1.E.3 流程控制
- if 语句
    - `if` 语句的最简单构成是这样 —— 注意第 1 行末尾的冒号 `:` 和第 2 行的缩进：

    ```python
    if expression:
        statements
    ```

    如果表达式 `expression` 返回值为真，执行 `if` 语句块内部的 `statements`，否则，什么都不做，执行 `if` 之后的下一个语句。
    - elif if语句的其他多种情况 或者直接使用 else 只有2种可能
- for 循环
    - Python 语言中，`for` 循环不使用其它语言中那样的计数器，取而代之的是 `range()` 这个我称其为 “整数等差数列生成器” 的函数。
      ```python
        for a in range(10): 
            
            print(f'value of a: {a}') #每次 a 的值都不同，从 0 递增至 9
      ```
- range()函数
    - range(stop)
    - range(start, stop[, step])
- Continue、Break 和 Pass
    - continue 结束当前的迭代（语句将忽略其后的语句），到下一轮的迭代去
    - Break 立刻终止当前的循环
    - pass 占位符
- while 循环
    - `while` 循环的格式如下：

        ```python
        while expression:
            statements
        ```
    - `for` 和 `while` 的区别在哪里？什么时候应该用哪个？

        `for` 更适合处理序列类型的数据（Sequence Type）的迭代，比如处理字符串中的每一个字符，比如把 `range()` 返回的数列当作某种序列类型的索引。
        
        `while` 更为灵活，因为它后面只需要接上一个逻辑表达式即可。

## PART.1.E.4 函数
- print()函数
    - print(*object, sep=' ', end='\n', file=sys.stdout, flush=False)
> print('Hello', 'world!', sep=' ', end='\n', file=sys.stdout, flush=False)
> - 'Hello'和'world!'是要打印的两个字符串。
> -  sep=' '指定了打印时两个字符串之间的分隔符为一个空格。
> -  end='\n'指定了打印结束后要输出的字符为换行符，即在字符串后换行。
> - file=sys.stdout指定了输出的目标为标准输出流（控制台）。
> - flush=False表示在打印完毕后不强制刷新输出缓冲区。
- 1.2. 关键字参数
    - 在 Python 中，函数的参数，有两种：
        > * **位置参数**（Positional Arguments，在官方文档里常被缩写为 *arg*）
        > * **关键字参数**（Keyword Arguments，在官方文档里常被缩写为 *kwarg*）
        - 在函数定义中，带有 `=` 的，即，已为其设定了默认值的参数，叫做 Keyword Arguments，其它的是 Positional Arguments。
- 1.3. 位置参数
    - divmod() 它接收且必须接收两个参数。
    - 当你调用这个函数的时候，括号里写的第一个参数，是被除数，第二个参数是除数 —— 此为该函数的输入；
        而它的返回值，是一个元组（Tuple，至于这是什么东西，后面讲清楚），其中包括两个值，第一个是商，第二个是余 —— 此为该函数的输出。
- 1.4. 可选位置参数
    - pow()
    - exec()
- 1.5. 可接收很多值的位置参数
    - max(argl, arg2,*args[, key])  key=len key可以指定比较长度
- 1.6 Class 也是函数
    - class bool([x])
- 1.7. 总结
    > * 你可以把函数当作一个产品，而你自己是这个产品的用户；
    > * 既然你是产品的用户，你要养成好习惯，一定要亲自阅读产品说明书；
    > * 调用函数的时候，注意*可选位置参数的使用方法*和*关键字参数的默认值*；
    > * 函数定义部分，注意两个符号就行了，`[]` 和 `=`；
    > * 所有的函数都有返回值，即便它内部不指定返回值，也有一个默认返回值：`None`；
    > * 另外，一定要耐心阅读该函数在使用的时候需要注意什么 —— 产品说明书的主要作用就在这里……

### PART.1.E.5.字符串
- 1.字符串
    -在计算机里，所有的东西最终都要被转换成数值。又由于计算机靠的是电路，所以，最终只能处理 `1` 和 `0`，于是，最基本的数值是二进制；于是，连整数、浮点数字，都要最终转换成二进制数值。这就是为什么在所有编程语言中 `1.1 + 2.2` 并不是你所想象的 `3.3` 的原因。
- 1.1 字符码表的转换
    - ord() 单个字符转换成码值  ord('a')
    - chr() 单个码值转换成字符  chr(122)
- 1.2. 字符串的标示
    - 标示一个字符串，有 4 种方式，用单引号、用双引号，用三个单引号或者三个双引号
    - 'Simple is better than complex.'
    - "Simple is better than complex."
    - '''Simple is better than complex.'''
    - """Simple is better than complex."""
- 1.3. 字符串与数值之间的转换
    - int('3')
    - float('3')
    - str(3.1415926)
    - int('3.1415926') # 这一行会报错
- 1.4. 转义符
    - '\'
    - 'He said, it\'s fine.'
    - \ 是用来告诉计算机我这句话里面的'是字符而非字符串结尾
    - 搭配：`\t`= TAB按键
    - 搭配：`\n`=ENTER按键
    
- 1.5. 字符串的操作符
    - “+”
    - “ ”
    - 3*str
    - 字符串还可以用 in 和 not in 操作符 —— 看看某个字符或者字符串是否被包含在某个字符串中，返回的是布尔值：
- 1.6. 字符串的索引
    - 字符串是由一系列的字符构成的。在 Python 当中，有一个容器（Container）的概念，这个概念前面提到过，后面还会深入讲解。现在需要知道的是，字符串是容器的一种；容器可分为两种，有序的和无序的 —— 字符串属于有序容器。
    - s = 'Python'
    - s[1]
    - s[2:]
    - s[2:5]
    - s[:5]
    - s[1:5:2]
- 1.7. 处理字符串的内建函数
    - Python 内建函数中，把字符串当做处理对象的有：ord()、input()、int()、float()、len()、print()。再次注意，ord() 只接收单个字符为参数。
- 1.8. 处理字符串的 Method
    - 'Python'.upper() 字符串本身是一个对象，可以用很多的函数
    - 1.8.1. 大小写转换
    - 1.8.2. 搜索与替换
    - 1.8.3. 去除子字符
    - 1.8.4. 拆分字符串
    - 1.8.5. 拼接字符串
    - 1.8.6. 字符串排版
    - 1.8.7. 格式化字符串
    - 1.8.8. 字符串属性
- 1.9. 总结
    - ![](../images/string-concepts.png)
- 1.10. 为什么数值没有像字符串值这样详细论述？
    - Python 针对数字常用的操作符和内建函数，按照**优先级**从低到高排列：
|名称  | 操作               | 结果                                                       | 官方文档链接                                           |
| --- | ----------------- | ------------------------------------------------------------| ------------------------------------------------------------ |
| 加  | `1 + 2`           | 3                                          |                                                              |
| 减  | `2 - 1`           | 1                                    |                                                              |
| 乘  | `3 * 5`           | 15                                       |                                                              |
| 除  | `6 / 2`           | 3.0                                      |                                                              |
| 商  | `7 // 3`          | 2                              |                                                              |
| 余  | `7 % 3`           | 1                              |                                                              |
| 负  | `-6`              | -6                             |                                                              |
| 正  | `+6`              | 6                              |                                                              |
| 绝对值 | `abs(-1)`         | 1                           | [`abs()`](https://docs.python.org/3/library/functions.html#abs) |
| 转换为整数| `int(3.14)`       | 3                        | [`int()`](https://docs.python.org/3/library/functions.html#int) |
| 转换为浮点数 | `float(3)`        | 3.0                   | [`float()`](https://docs.python.org/3/library/functions.html#float) | 
| 商余 | `divmod(7, 3)`    | 2, 1                         | [`divmod()`](https://docs.python.org/3/library/functions.html#divmod) | 
| 幂 | `pow(2, 10)`      | 1024                          | [`pow()`](https://docs.python.org/3/library/functions.html#pow) |
| 幂 | `3 ** 2`          | 9                             |                                                              |

    -Python 用来处理数值的内建函数：

> * `abs(n)` 函数返回参数 `n` 的*绝对值*；
> * `int(n)` 用来将*浮点数字* `n` 转换成*整数*；
> * `float(n)` 用来将*整数* `n` 转换成*浮点数字*；
> * `divmod(n, m)` 用来计算  `n`  除以  `m`，返回两个整数，一个是*商*，另外一个是*余*；
> * `pow(n, m)` 用来做乘方运算，返回 `n` 的 `m` *次方*；
> * `round(n)` 返回离浮点数字 `n` 最近的那个*整数*。

### PART.1.E.6.CONTAINERS 数据容器
- 数据容器包含
    - **字符串**
    - 由 `range()` 函数生成的**等差数列**
    - **列表**（List）
    - **元组**（Tuple）
    - **集合**（Set）
    - **字典**（Dictionary） 
    - ![](../images/python-containers-final.png) 
- 1.1. 迭代（Iterate）
    - for c in 'Python':
      print(c)
- 1.2. 列表（List）
    - 1.2.1. 列表的生成
        - a_list = []
        - b_list = [1, 2, 3] 
        - list(), or list(iterable)            # 这是 Type Casting 
        - [(expression with x) for x in iterable] 
    - 1.2.2. 列表的操作符
    - 1.2.3. 根据索引提取列表元素
        - 需要注意的地方是：列表（List）是可变序列，而字符串（str）是不可变序列，所以，对字符串来说，虽然也可以根据索引提取，但没办法根据索引删除或者替换。
    - 1.2.4. 列表可用的内建函数
        > * `len()` 
        > * `max()` 
        > * `min()`
    - 1.2.5. Methods
        - 字符串常量和 range() 都是不可变的（Immutable）；而列表则是可变类型（Mutable type），所以，它最起码可以被排序 —— 使用 sort() Method：
        - 可变序列还有一系列可用的 Methods：a.append()，a.clear()，a.copy()，a.extend(t)，a.insert(i，x)，a.pop([i])，a.remove(x)，a.reverse()……    
        - .copy() 和'='方法区别，.copy()创建的副本是一个新的对象，对副本的修改不会影响原始对象，而赋值操作符 = 创建的是一个新的引用，新引用和原始引用指向同一个对象，因此对其中一个的修改会影响另一个。
    - 1.2.6 小结
        - ![](../images/list-concepts.png)  
         
    - 1.3. 元组（Tuple）
        - 注意：创建单个元素的元组，无论是否使用圆括号，在那唯一的元素后面一定要补上一个逗号 ,
        - 元组是不可变序列，所以，你没办法从里面删除元素。
        - 但是，你可以在末尾追加元素。
        - 所以，严格意义上，对元组来讲，“不可变” 的意思是说，“当前已有部分不可变”……
        - 初学者总是很好奇 List 和 Tuple 的区别。首先是使用场景，在将来需要更改的时候，创建 List ；在将来不需要更改的时候，创建 Tuple。其次，从计算机的角度来看，Tuple 相对于 List 占用更小的内存。
    - 1.4. 集合（Set）
        - 这个容器类型与列表不同的地方在于，首先它*不包含重合元素*，其次它是*无序*的；进而，集合又分为两种，Set，*可变的*，Frozen Set，*不可变的*。
        - 创建空集合注意点：空集合要用set()，而不能用{}
    - 1.4.2 操作
        - 把序列转成集合就等于去重
        - 对于集合，推荐更多使用 Methods 而不是操作符的主要原因是：更易读 —— 对人来说，因为有意义、有用处的代码终将需要人去维护。

| 意义 | 操作符 |Methods | Methods 相当于 |
| - | -| - |- |
| 并集 | <code>&#124;</code> | `set.union(*others)` | <code>set &#124; other &#124; ...</code> |  
| 交集 | `&` | `set.intersection(*others)`|\`set & other & ... \` | 
| 差集 | `-` |\` set.difference(\*others)\`| `set - other - ...` |  
| 对称差集 | `^` | `set.symmetric_difference(other)` | `set ^ other` | 


- 1.4.3. 逻辑运算
- 1.4.4. 更新
    - add(elem) 把 elem 加入集合
    - remove(elem) 从集合中删除 elem；如果集合中不包含该 elem，会产生 KeyError 错误。
    - discard(elem) 如果该元素存在于集合中，删除它。
    - pop() 从集合中随机删除一个元素，并返回删除的元素的值，针对空集合做此操作会产生 KeyError 错误。
    - clear() 从集合中删除所有元素。
    - set.update(*others)
    - set.intersection_update(*others)
    - set.difference_update(*others)
    - set.symmetric_difference_update(other)
- 1.4.5. 冻结集合 还有一种集合，叫做冻结集合（Frozen Set），Frozen Set 之于 Set，正如 Tuple 之于 List，前者是不可变容器（Immutable），后者是可变容器（Mutable），无非是为了节省内存使用而设计的类别。
- 1.5. 字典（Dictionary）
    - 字典这个数据类型之所以叫做 Map（映射），是因为字典里的 key 都映射且只映射一个对应的 _value_。
    - 1.5.1. 字典的生成 bDict = {'a':1, 'b':2, 'c':3}
    - 1.5.2. 更新某个元素 phonebook1['joe'] = 5802
    - 1.5.3. 添加元素 phonebook1.update( {'john':9876})
    - 1.5.4. 删除某个元素 del phonebook1['ann']
    - 1.5.5. 逻辑操作符 'stan' in phonebook1.keys()
    - 1.5.6. 可用来操作的内建函数
        -  len(phonebook1) 长度
        -  max(phonebook1) 最大那个
        -  min(phonebook1) 最小那个
        -   list(phonebook1) 转成list
        -   tuple(phonebook1) 转成tuple
        -    set(phonebook1)  转成集合
        -    sorted(phonebook1) 排序
        -   sorted(phonebook1, reverse=True) 倒序
    - 1.5.7. 常用 Methods
        - .copy()
        - .clear()
        - .popitem()
        - .pop('adam', 3538)
        - .get('adam', 3538)
        - .etdefault('adam', 3538)
          
    - 1.6. 迭代各种容器中的元素     
### Part.1.E.7.files  
这一章我们介绍了文本文件的基本操作：

> * 打开文件，直接用内建函数，`open()`，基本模式有 `r` 和 `w`；
> * 删除文件，得调用 `os` 模块，使用 `os.remove()`，删除文件前最好确认文件确实存在……
> * 读写文件分别有 `file.read()`、`file.write()`、`file.readline()`、`file.readlines()`、`file.writelines()`；
> * 可以用 `with` 把相关操作都放入同一个语句块……

### Part.1.F.deal-with-forward-references
>
		

    